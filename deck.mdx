import { Head, Notes, Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";
import List from './components/List'
import FullImage from './components/FullImage'
import lighthouseAudit1 from './images/lighthouse-audits-start-useReact.png'
import lighthouseAudit2 from './images/lighthouse-a11y-results-useReact.png'
import lighthouseAudit3 from './images/lighthouse-a11y-results-expanded-useReact.png'
import lighthouseAudit4 from './images/lighthouse-results-all-useReact.png'
import reactAxeDemo from './images/react-axe-demo.gif'
import failedFocusTest from './images/failed-focus-test.png'
import onBlurError from './images/on-blur-error-useReact.gif'


export const theme = vsDark;

<Head>
  <title>How to do without doing anything</title>
</Head>

# Hello üëã

You are using [MDX Deck](https://github.com/jxnblk/mdx-deck) and [Code Surfer](https://codesurfer.pomb.us)

---

# Yuraima Estevez

<List>
  <li>üë©‚Äçüíª Tech Lead</li>
  <li>üì∞ The New York Times</li>
  <li>üê∂ Love Dogs</li>
</List>

---

# "How much do you love dogs?"
\- You, probably

---

<Notes>

- besides dogs i also love to make the web better for  everyone
- what does that mean for me? building community and culture as a meetup organizer and tech leader at work.
- going to conferences and teaching folks how they can make the web better for everyone
- and of course that comes in the form of advocating for accessibility on the web.  Why?
- because at its core, web accessibility is about making apps, sites and tools that work for everyone including people with disabilities.
- and when we build things that can work for everyone on the web, we in turn mak the web better for everyone.
- a11y can be hard, but that doesn't mean we're allowed to just ignore it.
- in fact, we should be looking for opportuninties where we can set ourselves up to be more efficient and resilient in our accessibility practices so that over time we can free ourselves up to dedicating the time and resources we save on solving complex problems.
- And that's where testing and automation come into play.
- As engineers we've already embraced the practice of protecting ourselves from bugs by writing tests and cutting time in our development process through continuous integrations and development.
- We can take those same practices and apply them to developing accessible sites and apps.
- And when we invest in testing and automating parts of our accessibility development, we build confidence in our systems that they will work for everyone, and consequently, make the web better for everyone.
- So today, we're going to talk about how we can do good, without doing anything...
- title thing about it  being somewhat click baity.


</Notes>

---

# Development
What you can do when you're writing you're code.

---

# [Lighthouse](https://developers.google.com/web/tools/lighthouse)
An open-source, automated tool for improving the quality of web pages.

<Notes>

- Allows you to run accessibility audits on your website.
- You'll receive a score for how accessible your site is.
- Let you know where you can improve your score and make your site more accessible.

</Notes>

---

# [Lighthouse](https://developers.google.com/web/tools/lighthouse)

<List bullets appear={false}>
  <li>Chrome DevTools</li>
  <li>Command Line</li>
  <li>CI Systems</li>
  <li>Web UI</li>
</List>

---

# [Lighthouse](https://developers.google.com/web/tools/lighthouse)

<List bullets appear={false}>
  <li>Chrome DevTools üëà</li>
  <li>Command Line</li>
  <li>CI Systems</li>
  <li>Web UI</li>
</List>

---

<!-- shows the lighthouse accessibility audit for useReact.nyc website -->

<Image src={lighthouseAudit1} />

<Notes>

- Lighthouse comes baked into Chrome DevTools
- If you open the "Audits" tab you'll see a list of audits that you can run.

</Notes>

___

<!-- shows the lighthouse accessibility audit results for useReact.nyc website -->

<Image src={lighthouseAudit2} />

<Notes>

- We can choose the accessibility audit to run and lighthouse will give us a score out of 100.
- This lets us know how accessible our website is by checking if we're adhereing to accessibility standards and best practices.

</Notes>

___

<!-- shows all lighthouse audit results for useReact.nyc website -->

<Image src={lighthouseAudit3} />

<Notes>

- Along with our score we get a list of improvements to make that will help us make our website more accessible.
- I like to run lighthouse in the devtools when I want to get a sense of a site's baseline accessibility score.
- Or as I make changes to make sure I'm not unintentionally degrading my accessibility support.

</Notes>

___

<!-- shows expanded results for useReact.nyc website -->

<Image src={lighthouseAudit4} />

<Notes>

- One perk that lighthouse gives us is that you can use it for running other audits, not just accessibility.
- Performance, best practices, seo, progressive web apps.
- All of this is rolled into one tool so that you can make sure you're building a top quality site without a ton of additional work on your end.

</Notes>

___

# [react-axe](https://github.com/dequelabs/react-axe)
Open source tool that tests the accessibility of React applications and displays the results in the Chrome DevTools console.

---

<!-- react-axe import code  -->

<CodeSurfer>

```js file=./code/react-axe-import.js
```

```js 4:5 file=./code/react-axe-import.js
```

</CodeSurfer>

<Notes>

- Here's how you would use react-axe in your projects.
- NEXT SLIDE
- Note that I'm only running react-axe in NON-PRODUCTION environments.
- It'll be clear why we do that when we see how it works.

</Notes>

___

<!-- react-axe walkthrough gif -->

<FullImage src={reactAxeDemo} />

<Notes>

- Once we have react-axe included in our project, we can load our site and open up the DevTools console.
- And we see that react-axe is adding messages to our console highlighting accessibility errors on the page.
- These messages include a severity rating (minor, moderate, serious) to signal how critical an error is.
- Also includes a link to a helpful resource that gives us details on the error and how we can fix it.
- Different from lighthouse which checks statically, this will evaluate our site as we interact with it.
- That's why we only run in non-production environments, because the performance hit would be detrimental.

</Notes>

---

# Testing

<Notes>

- Let's move on to adding automated tests to test the accessibility of our apps.
- Quick disclaimer: I'll share the tools I use, but the frameworks and libraries here don't matter
- Pay attention to what I test and why it's important to test them.

</Notes>

___

# Testing

<List>
  <li>Unit Tests</li>
  <li>Integration Tests</li>
  <li>End-to-end Tests</li>
</List>

<Notes>

- Covering three kinds of tests.  These are the most common.

</Notes>

___

# Unit Tests

<List>
  <li>Component API and Behavior</li>
  <li>ARIA attributes</li>
  <li>Focus States</li>
</List>

<Notes>

- testing individual, stand-alone components.
- Can validate a component's api and behavior.
- That there are aria attributes present and their values.
- Keyboard navigation.

</Notes>

---

# [Jest](https://jestjs.io/en/)

<Notes>

- Testing framework that's usually paired with React
- framework, library, environemnt agnostic

</Notes>

---

# [react-testing-library](https://testing-library.com/docs/react-testing-library/api)

<Notes>

- library full of helpful testing methods for querying and matching values.
- part of a larger testing suite called testing-library with many other libraries that are tech agnostic.

</Notes>

---

<!-- button component code -->

<CodeSurfer>

```js file=./code/unit-test-0.0.0.js
```

```js 6,14 file=./code/unit-test-0.0.0.js
```

</CodeSurfer>

<Notes>

- Let's start off with a simple, accessible button.
- And let's test that our button will render the right ARIA attribute when it's passed as a prop.

</Notes>

---

# [ARIA Attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)
HTML attributes that help define the semantics of an element or component for assistive technologies.

*[check out my talk on building accessible components](https://youtu.be/lxxYParyAGk?t=24456)
<Notes>

- ARIA attributes provide more information to assistive technologies like a screen reader so they understand our components.
- We want to make sure that we're including them where appropriate, making them perfect to test for.
- Go to my talk on accessible components to learn more about ARIA and how to use. 

</Notes>

---

<!-- button component highlighting aria-label -->

<CodeSurfer>

```js 13,14 file=./code/unit-test-0.0.0.js
```

</CodeSurfer>

<Notes>

- The ARIA attribute we want to test for here is called 'aria-label'
- it provides a label for the element it's applied to so that something like a screen reader can announce to users.


</Notes>

---

<!-- step through button test for aria-label  -->

<CodeSurfer>

```js file=./code/unit-test-0.0.1.js
```

```js 1 file=./code/unit-test-0.0.1.js
```

```js 2:6 file=./code/unit-test-0.0.1.js
```

```js 7:8 file=./code/unit-test-0.0.1.js
```

```js 10 file=./code/unit-test-0.0.1.js
```

</CodeSurfer>

<Notes>

- Here's how I'd write a test for this component.  Let's step through
- testing to make sure we don't render the aria-label attribute unless we have the right prop.
- if aria-label present and empty, a screen reader will not announce the button at all and our user won't know the button is there.
- NEXT: construct our accessible button component and make sure not to pass the accessibleLabel prop
- NEXT: render that button and query for the button node
- NEXT: what we care about. asserting that our rendered button does NOT have an aria-label attribute
- again, testing library/framework don't matter.  APIs differ, focus on testing the presence or absence of the aria attribute.

</Notes>

---

<!-- button test that the aria label is there -->

<CodeSurfer>

```js file=./code/unit-test-0.0.2.js
```

```js 5,12 file=./code/unit-test-0.0.2.js
```

</CodeSurfer>

<Notes>

- Also test that the label attribute is there when we do pass the prop to it.
- most is the same, but passing the accessibleLabel attribute.
- and asserting that our button does have the aria-label attribute
- and it's set to the label that we passed to our component.

</Notes>

---

<!-- button test for focus on the button -->

<CodeSurfer>

```js file=./code/unit-test-0.0.3.js
```

```js 10 file=./code/unit-test-0.0.3.js
```

```js 11 file=./code/unit-test-0.0.3.js
```

</CodeSurfer>

<Notes>

- Let's set up another test, this time for focus.
- Testing that our components can gain focus is good for testing keyboard navigation.
- All of our interactive elements need to support keyboard only users.
- only elements that can be focused are interactible with a keyboard
- NEXT: call the focus method on our button.
- NEXT: check that our button is now focused

</Notes>

---

<!-- accessible button with div subbed in -->

<CodeSurfer>

```js file=./code/unit-test-0.0.0.js
```

```js 8,17 file=./code/unit-test-0.0.0.js
```

```js 8,17 file=./code/unit-test-0.0.4.js
```

</CodeSurfer>

<Notes>

- This test protects us in the future from introducing bugs that break keyboard navigation.
- By default html buttons support keyboard nav and focus.
- NEXT: but what if someone comes by and changes our button to a div?
- divs are not focusable elements, and therefore will not support keyboard nav.

</Notes>

---

<!-- failed test for focusing button -->

<FullImage src={failedFocusTest} />

<Notes>

- now this will fail our test and let us know that we've likely introduced a bug in our code that breaks keyboard navigation for our users.

</Notes>

---

# Integration Tests
How individual components interact with each other

<Notes>

- Let concerned about component APIs
- More about the outcomes of how components interact with each other.
- Can also test aria attributes and make sure supporting keyboard nav when components come together.

</Notes>

---

<!-- Slack component demo gif  -->

<FullImage src={onBlurError} />

<Notes>

- example from useReact website
- slack sign up via email.
- when i focus into the email input and then blur out, validation is run.
- if no valid email, red outline is added to input to signal that i need to add an email.
- i also need to make sure my screen reader users are notified of this error somehow.
- and that's what we're going to test, to make sure that my signal for assistive technologies works.

</Notes>

---

<!-- Slack component code intro -->

<CodeSurfer>

```js file=./code/integration-test-0.0.0.js
```

```js 6,7,8,9,15,19 file=./code/integration-test-0.0.0.js
```

```js 28,29 file=./code/integration-test-0.0.0.js
```

</CodeSurfer>

<Notes>

- Let's take a look at this component.
- Composed of multiple components that this container passes props to.
- NEXT: Accessible input accepts onBlur function 
- NEXT: This function validates our email when a user unfocuses the input
- NEXT: And there's an accessible alert component that accepts an error message if there's an error with validation.

</Notes>

---

<!-- Accessible alert component walkthrough -->

<CodeSurfer>

```js file=./code/integration-test-0.0.1.js
```

```js 2 file=./code/integration-test-0.0.1.js
```

```js 3 file=./code/integration-test-0.0.1.js
```

</CodeSurfer>

<Notes>

- Here's our accessible alert component
- NEXT: it's visually hidden so it doesn't show up on the page because this component is only here for assistive technologies.
- NEXT: role=alert. aria attribute that will announce changes to this component.  When we add an error message, a screen reader will announce that message.
- empty to start because only changes to the node are announced.

</Notes>

---

<!-- Accessible alert test walkthrough -->

<CodeSurfer>

```js file=./code/integration-test-0.0.2.js
```

```js 5 file=./code/integration-test-0.0.2.js
```

```js 6:9 file=./code/integration-test-0.0.2.js
```

```js 11:16 file=./code/integration-test-0.0.2.js
```

```js 18:23 file=./code/integration-test-0.0.2.js
```

</CodeSurfer>

<Notes>

- Let's look at a simple test I could write to make sure that this actually happens with all of my different components in the SlackSignupContainer.
- NEXT: test that my alert is updated when the input is blurred.
- NEXT: render my signup container component and get references to input and alert components.
- NEXT: focus into my input and assert that my alert contains no text in it.
- NEXT: blur out without a valid email, assert that my alert component does receive our error message.


</Notes>

---

# Manual Testing

<Notes>

- the presence of automated tests doesn't absolve you from manually testing your applications.
- Tests provide you with the peace of mind that fewer bugs will unintentionally be introduced into your codebase
- but tests won't protect you from weird edge cases or uncover that the user flow you designed doesn't actually work for the user once its in their hands.
- And that means we still have to manually test some things.
- But the time that we save because we invested in automating certain aspects of of our development process automatically gets redistributed to parts of our applications that require a finer touch or a sharper eye.
- And this is especially important when we're building out accessibility features in our applications.
- It isn't always easy to go off of the accessibility documentation and know whether or not you've implented something correctly.
- And sometimes, even when we think we have a perfectly accessible solution, we find out that it's not quite right when it's used in the real world by a person with disabilities.
- And this is where our freed up time gets reinvested.  When testing and automation pick up the bulk of the repetitive work and QA process, we can spend more time working to solve these more nuanced challenges and building out amazing, accessible features.

</Notes>
