import { Head, Notes, Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import './styles.css'
import customTheme from './theme'
export const theme = customTheme;

import Layout from './components/Layout'
import List from './components/List'
import FullImage from './components/FullImage'
import lighthouseAudit1 from './images/lighthouse-audits-start-useReact.png'
import lighthouseAudit2 from './images/lighthouse-a11y-results-useReact.png'
import lighthouseAudit3 from './images/lighthouse-a11y-results-expanded-useReact.png'
import lighthouseAudit4 from './images/lighthouse-results-all-useReact.png'
import reactAxeDemo from './images/react-axe-demo.gif'
import failedFocusTest from './images/failed-focus-test.png'
import onBlurError from './images/on-blur-error-useReact.gif'
import cypressA11yFail from './images/cypress-a11y-fail.png'
import altTextUseReact from './images/alt-text-useReact.png'


<Head>
  <title>How to do Good, Without Doing Anything</title>
</Head>

<Layout>

# Hello üëã

</Layout>


<Notes>

- hope everyones cozying up at home, washing their hands and social distancing.
- I myself will be dialing into this conference from my couch in cozy sweat pants with an offensively large cup of tea.

</Notes>

---

<Layout>

# Yuraima Estevez

<List>
  <li>üë©‚Äçüíª Tech Lead</li>
  <li>üì∞ The New York Times</li>
</List>

</Layout>

---

<Layout>

<List>
  <li><h1>Accessibility</h1></li>
  <li><h1>Testing</h1></li>
  <li><h1>Automation</h1></li>
</List>

</Layout>


<Notes>

- As engineers we've already embraced the practice of protecting ourselves from bugs by writing tests and cutting time in our development process through continuous integrations and development.

</Notes>

---

<Layout>

<List appear={false}>
  <li><h1>Accessibility</h1></li>
  <li><h1>Testing</h1></li>
  <li><h1>Automation</h1></li>
</List>

</Layout>



<Notes>

- We can take those same practices and apply them to developing accessible sites and apps.
- And when we invest in testing and automating parts of our accessibility development, we save time and build confidence in our systems that they will work for everyone, and consequently, make the web better for everyone.
- So today, we're going to talk about...

</Notes>

---

# How to do Good, Without doing Anything

---

<Layout>

<List>
  <li><h1>Tools</h1></li>
  <li><h1>Testing</h1></li>
</List>

</Layout>

<Notes>

- break this up into two parts.
- TOOLS. automated tools used at different stages of my development process.
- helps automate the harder tasks that we often do and help keep my codebases free of accessibility bugs
- TESTING. what kinds of test we write and what we want to validate when it comes to accessibility support in our components and apps.

</Notes>

---

<Layout>

<List appear={false}>
  <li><h1>Tools</h1></li>
  <li><h1>Testing</h1></li>
</List>

</Layout>


<Notes>

- disclaimer: i primarily work in javascript specifically react on the FE. Lots of my examples will be in react.  But almost everything in this talk is agnostic of language, framework, library. 
- the impolementation details will be specific to your code bases, but you can use the types of tools and strategies in this talk to help guide those decisions on how to make a path forward for yourself.

</Notes>

---

<Layout>

# Tools

</Layout>


<Notes>

- kick it off with tools.

</Notes>

---

<Layout>

## [`eslint-plugin-jsx-a11y`](https://github.com/evcohen/eslint-plugin-jsx-a11y)
Set of accessibility linter rules that checks JSX elements during development

</Layout>

<Notes>

- low lift, most people already have linters
- Helps you catch common accessibility mistakes in your code while your developing
- Automate it using git hooks to prevent inaccessible code from getting committed
- Can use it in your CI/CD pipeline to fail builds that don‚Äôt pass and prevent accessibility issues from making it into production

</Notes>

---

<Layout>

# [Lighthouse](https://developers.google.com/web/tools/lighthouse)
An open-source, automated tool for improving the quality of web pages.

</Layout>


<Notes>

- Allows you to run accessibility audits on your website.

</Notes>

---

<Layout>

# [Lighthouse](https://developers.google.com/web/tools/lighthouse)

</Layout>


<List bullets appear={false}>
  <li>Chrome DevTools</li>
  <li>Command Line</li>
  <li>CI Systems</li>
  <li>Web UI</li>
</List>

<Notes>

- comes in different flavors
- all of these do the same thing, just depends on how we want to use it based on preference.

</Notes>

---

<!-- shows the lighthouse accessibility audit for useReact.nyc website -->

<Image src={lighthouseAudit1} />

<Notes>

- for now let's look at lighthouse in chrome devtools.
- If you open the "Audits" tab you'll see a list of audits that you can run and some different options we can set.
- using the useReactNYC website for demonstrations.

</Notes>

___

<!-- shows the lighthouse accessibility audit results for useReact.nyc website -->

<Image src={lighthouseAudit2} />

<Notes>

- We can choose the accessibility audit to run and lighthouse will give us a score out of 100.
- This lets us know how accessible our website is by checking if we're adhereing to accessibility standards and best practices.

</Notes>

___

<!-- shows all lighthouse audit results for useReact.nyc website -->

<Image src={lighthouseAudit3} />

<Notes>

- Along with our score we get a list of where we lost points, and how we can fix these errors.
- I like to run lighthouse in the devtools when I want to get a sense of a site's baseline accessibility score.
- Or as I make changes to make sure I'm not unintentionally degrading my accessibility support.

</Notes>

___

<!-- shows expanded results for useReact.nyc website -->

<Image src={lighthouseAudit4} />

<Notes>

- One perk that lighthouse gives us is that you can use it for running other audits, not just accessibility.
- Performance, best practices, seo, progressive web apps.
- All of this is rolled into one tool so that you can make sure you're building a top quality site without a ton of additional work on your end.

</Notes>

___

<Layout>

# [`react-axe`](https://github.com/dequelabs/react-axe)
Open source tool that tests the accessibility of React applications and displays the results in the Chrome DevTools console.

</Layout>

___

<!-- react-axe walkthrough gif -->

<FullImage src={reactAxeDemo} />

<Notes>

- using the times wellness challenge as a demonstration 
- open up the DevTools console.
- adding messages to our console highlighting accessibility errors on the page.
- Includes a severity rating (minor, moderate, serious).
- a link to a helpful resource for details on the error and how we can fix it.
- Lighthouse checks static page loads. react axe is working as we use it, evaluates the rerenders with every interaction.

</Notes>

---

<Layout>

# [`axe-core`](https://github.com/dequelabs/axe-core)
Accessibility engine for automated Web UI testing

</Layout>

<Notes>

- Last one for today
- has a really powerful API for running automated accessibility tests and processes.
- both lighthouse and react-axe are built with the axe-core api.

</Notes>

---

<Layout>

# Testing

<ul style={{opacity: 0}}>
  <li>Unit Tests</li>
  <li>Integration Tests</li>
  <li>End-to-end Tests</li>
</ul>

</Layout>


<Notes>

- Let's move on to adding automated tests to check the continued accessibility of our apps.
- Quick disclaimer: I'll share the tools I use, but the frameworks and libraries here don't matter
- Pay attention to what I test and why it's important to test them.

</Notes>

___

<Layout>

# Testing

<List appear={false}>
  <li>Unit Tests</li>
  <li>Integration Tests</li>
  <li>End-to-end Tests</li>
</List>

</Layout>


<Notes>

- Covering three kinds of tests.  These are the most common.

</Notes>

___
<Layout>


# Unit Tests

<List appear={false}>
  <li>Component API and Behavior</li>
  <li>ARIA attributes</li>
  <li>Focus States</li>
</List>

</Layout>


<Notes>

- testing individual, stand-alone components.
- Can validate a component's api and behavior.
- That there are aria attributes present and their values.
- Keyboard navigation.

</Notes>

---

<Layout>

<List appear={false}>

  <li><h2><a href="https://jestjs.io/en/">Jest</a></h2></li>
  <li><h2><a href="https://testing-library.com/docs/react-testing-library/api">react-testing-library</a></h2></li>

</List>

</Layout>


<Notes>

- Usually use these, but you can use whatever works for you.

</Notes>

---

<!-- button component code -->

<CodeSurfer>

```js file=./code/unit-test-0.0.0.js
```

```js 6,14 file=./code/unit-test-0.0.0.js
```

</CodeSurfer>

<Notes>

- Let's start off with a simple, accessible button.
- NEXT: passing accessibleLabel and conditionally rendering.
- aria-label provides a label for the element it's applied to so that something like a screen reader can announce to users.

</Notes>

---

<!-- step through button test for aria-label  -->

<CodeSurfer>

```js file=./code/unit-test-0.0.1.js
```

```js 1 file=./code/unit-test-0.0.1.js
```

```js 2:6 file=./code/unit-test-0.0.1.js
```

```js 7:8 file=./code/unit-test-0.0.1.js
```

```js 10 file=./code/unit-test-0.0.1.js
```

</CodeSurfer>

<Notes>

- Let's step through
- NEXT: testing that we only render the aria-label when we have the right prop.
- NEXT: construct our accessible button component and make sure not to pass the accessibleLabel prop
- NEXT: render that button and query for the button node
- NEXT: what we care about. asserting that our rendered button does NOT have an aria-label attribute

</Notes>

---

<!-- button test that the aria label is there -->

<CodeSurfer>

```js file=./code/unit-test-0.0.2.js
```

```js 5,12 file=./code/unit-test-0.0.2.js
```

</CodeSurfer>

<Notes>

- Also test that the label attribute is there when we do pass the prop to it.
- NEXT: most is the same, but passing the accessibleLabel attribute.
- and asserting that our button does have the aria-label attribute
- and it's set to the label that we passed to our component.

</Notes>

---

<!-- button test for focus on the button -->

<CodeSurfer>

```js file=./code/unit-test-0.0.3.js
```

```js 10 file=./code/unit-test-0.0.3.js
```

```js 11 file=./code/unit-test-0.0.3.js
```

</CodeSurfer>

<Notes>

- Let's set up another test, this time for focus.
- Testing that our components can gain focus is good for testing keyboard navigation.
- All of our interactive elements need to support keyboard only users.
- only elements that can be focused are interactible with a keyboard
- NEXT: call the focus method on our button.
- NEXT: check that our button is now focused

</Notes>

---

<!-- accessible button with div subbed in -->

<CodeSurfer>

```js file=./code/unit-test-0.0.0.js
```

```js 8,17 file=./code/unit-test-0.0.0.js
```

```js 8,17 file=./code/unit-test-0.0.4.js
```

</CodeSurfer>

<Notes>

- This test protects us in the future from introducing bugs that break keyboard navigation.
- By default html buttons support keyboard nav and focus.
- NEXT: but what if someone comes by and changes our button to a div?
- divs are not focusable elements, and therefore will not support keyboard nav.

</Notes>

---

<!-- failed test for focusing button -->

<FullImage src={failedFocusTest} />

<Notes>

- now this will fail our test and let us know that we've likely introduced a bug in our code that breaks keyboard navigation for our users.
- These are the things we wanna make sure we're testing for.
- Find those test cases in our components that distills down exactly what the outcomes looks like through an accessible lense.
- If i have component that is interactive, that let's me know that i have to check focus to ensure keyboard nav support.
- When my components rely on aria attributes, validate that those attributes are present, and set with the correct values based on different props.

</Notes>

---

<Layout>

# Integration Tests
How individual components interact with each other

</Layout>


<Notes>

- What we just covered in unit tests can also be applied to integration test.
- Less concerned about component APIs
- More about the outcomes of how components come together.
- Can also test aria attributes and keyboard navigation, but this time in the context of multiple components working together.

</Notes>

---

<!-- Slack component demo gif  -->

<FullImage src={onBlurError} />

<Notes>

- example from useReact website
- slack sign up via email.
- when i focus into the email input and then blur out, validation is run.
- if no valid email, red outline is added to input to signal that i need to add an email.
- i also need to make sure my screen reader users are notified of this error somehow.
- and that's what we're going to test, to make sure that my signal for assistive technologies works.

</Notes>

---

<!-- Slack component code intro -->

<CodeSurfer>

```js file=./code/integration-test-0.0.0.js
```

```js 6,7,8,9,15,19 file=./code/integration-test-0.0.0.js
```

```js 28,29 file=./code/integration-test-0.0.0.js
```

</CodeSurfer>

<Notes>

- Let's take a look at this component.
- Composed of multiple components that this container passes props to.
- NEXT: Accessible input accepts onBlur function 
- NEXT: And there's an accessible alert component that accepts an error message if there's an error with validation.

</Notes>

---

<!-- Accessible alert component walkthrough -->

<CodeSurfer>

```js file=./code/integration-test-0.0.1.js
```

```js 2 file=./code/integration-test-0.0.1.js
```

```js 3 file=./code/integration-test-0.0.1.js
```

</CodeSurfer>

<Notes>

- Here's our accessible alert component
- NEXT: it's visually hidden so it doesn't show up on the page because this component is only here for assistive technologies.
- NEXT: role=alert. aria attribute that will announce changes to this component.  When we add an error message, a screen reader will announce that message.
- empty to start because only changes to the node are announced.

</Notes>

---

<!-- Accessible alert test walkthrough -->

<CodeSurfer>

```js file=./code/integration-test-0.0.2.js
```

```js 5 file=./code/integration-test-0.0.2.js
```

```js 6:9 file=./code/integration-test-0.0.2.js
```

```js 11:16 file=./code/integration-test-0.0.2.js
```

```js 18:23 file=./code/integration-test-0.0.2.js
```

</CodeSurfer>

<Notes>

- Let's look at a simple test SlackSignupContainer.
- NEXT: test that my alert is updated when the input is blurred.
- NEXT: render my signup container component and get references to input and alert components.
- NEXT: focus into my input and assert that my alert contains no text in it.
- NEXT: blur out without a valid email, assert that my alert component does receive our error message.
- Lots of moving parts, but guiding principles the same: check that components still manage ARIA correctly, keyboard nav.

</Notes>


---

<Layout>

# End-to-end Tests
Evaluate your entire app and full user flows

</Layout>


<Notes>

- tests that are the closest to how a user would experience your website.
- you can evaluate the same things as with user and integration tests,
- but do it within the context of fully fleshed out user flows, pages, or entire apps.


</Notes>

---

<Layout>

# [cypress.io](https://docs.cypress.io/guides/overview/why-cypress.html#In-a-nutshell)

</Layout>



<Notes>

- Open source e2e testing framework
- Great for browser driven testing.
- has excellent accessibility support.

</Notes>

---

<!-- Accessible alert test walkthrough -->

<CodeSurfer>

```js file=./code/e2e-test-0.0.0.js title="cypress-axe plugin"
```

</CodeSurfer>

<Notes>

- really like the cypress-axe plugin. powered by axe-core
- similar to lighthouse and react-axe, checks for accessibility errors, but built into your testing suite.
- keeps all of your validatio in one place, allows for easy integration in your ci/cd pipeline

</Notes>

---

<FullImage src={altTextUseReact} />

<Notes>

- Let's see how we can write our own e2e with a short and easy one.
- on the useReact website we have a section with all of the organizer photos.
- for screen reader support, all of these images need to have an alt attribute set.

</Notes>

---

<!-- Accessible alert test walkthrough -->

<CodeSurfer>

```js file=./code/e2e-test-0.0.1.js
```

```js 4 file=./code/e2e-test-0.0.1.js
```

```js 5 file=./code/e2e-test-0.0.1.js
```

```js 10:13 file=./code/e2e-test-0.0.1.js
```

```js 15:16 file=./code/e2e-test-0.0.1.js
```

</CodeSurfer>

<Notes>

- NEXT: let's check that when my page renders in the browser, organizers all have alt text
- NEXT: cypress query for our organizer images
- NEXT: then get the alt attribute values for all of our images.
- NEXT: and assert that this should have a length of 5, equal to the number of organizers we have.
- For the sake of time this is an overly simplified test. But what's important here is getting to the root of how a user would flow through our websie, and translating that into tests..

</Notes>

---

<!-- Accessible alert test walkthrough -->

<CodeSurfer>

```js file=./code/e2e-test-0.0.2.js
```

```js 4:6 file=./code/e2e-test-0.0.2.js
```

```js 24:26 file=./code/e2e-test-0.0.2.js
```

</CodeSurfer>

<Notes>

- Ask yourselves...
- NEXT: what should happen when I successfully submit my slack sign up form? what are the aria attr. and where does focus go?
- NEXT: Or what if a user navigates to a different page?  What do we expect the outcome is when we click a link in SPA, and what are the implications for accessibility support?

</Notes>

---

<Layout>

<List>
  <li><h1>Tools</h1></li>
  <li><h1>Testing</h1></li>
</List>

</Layout>

<Notes>

- And that brings me to the end of the basics so lets recap
- NEXT: tools, help prevent accessibility bugs from being introduced in writing code, commiting to code base, shipping to production.
- Generating audits and uncovering where we can improve our accessibility support.
- NEXT: In testing we covered unit, integration, e2e.  When to use each, what to test for each category.  And touched on the importance of manually testing and validating our accessibility support.

</Notes>

---

<Layout>

<List appear={false}>
  <li><h1>Tools</h1></li>
  <li><h1>Testing</h1></li>
</List>

</Layout>


<Notes>

- It was quite a bit to cover in the amount of time that we have, and there's still plenty to uncover that will help you create an accessibility development workflow that will benefit your projects and teams.
- But if there's one piece of advice i want to leave you with its this:
- It can feel really overwhelming if this is the first time you've thought about the accessibility of your products, and are taking stock of the work that needs to happen to bring it up to standards.
- But it's not expected that you to have a fully accessible site or 100% test coverage on day one.

</Notes>

---

<Layout>

<List appear={false}>
  <li><h1>Tools</h1></li>
  <li><h1>Testing</h1></li>
</List>

</Layout>


<Notes>

- make incremental changes where you can, and consistently chisel away at the accessiblity errors.
- eventually, implementing those small changes add up to possessing a deeper understanding of what it'll take to make your site accessible, and how to make it resilient against bugs.
- Once we have that understanding, and have our automation and testing processes in place, it'll be easier to make our websites work for everyone, and that means it'll be easier to build a better web for everyone.

</Notes>

---

# Thank You! 
